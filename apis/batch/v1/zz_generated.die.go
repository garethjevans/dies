//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2021 the original author or authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by diegen. DO NOT EDIT.

package v1

import (
	json "encoding/json"
	fmtx "fmt"
	metav1 "github.com/scothis/dies/apis/meta/v1"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	apismetav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
)

type CronJobDie struct {
	metav1.FrozenObjectMeta
	mutable bool
	r       batchv1.CronJob
}

var CronJobBlank = (&CronJobDie{}).DieFeed(batchv1.CronJob{})

func (d *CronJobDie) DieImmutable(immutable bool) *CronJobDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

func (d *CronJobDie) DieFeed(r batchv1.CronJob) *CronJobDie {
	if d.mutable {
		d.FrozenObjectMeta = metav1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &CronJobDie{
		FrozenObjectMeta: metav1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

func (d *CronJobDie) DieRelease() batchv1.CronJob {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

func (d *CronJobDie) DieStamp(fn func(r *batchv1.CronJob)) *CronJobDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

func (d *CronJobDie) DeepCopy() *CronJobDie {
	r := *d.r.DeepCopy()
	return &CronJobDie{
		FrozenObjectMeta: metav1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

func (d *CronJobDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *CronJobDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *CronJobDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *CronJobDie) UnmarshalJSON(b []byte) error {
	if d == CronJobBlank {
		return fmtx.Errorf("cannot unmarshal into the root object, create a copy first")
	}
	r := &batchv1.CronJob{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

func (d *CronJobDie) MetadataDie(fn func(d *metav1.ObjectMetaDie)) *CronJobDie {
	return d.DieStamp(func(r *batchv1.CronJob) {
		d := metav1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

func (d *CronJobDie) Spec(v batchv1.CronJobSpec) *CronJobDie {
	return d.DieStamp(func(r *batchv1.CronJob) {
		r.Spec = v
	})
}

func (d *CronJobDie) SpecDie(fn func(d *CronJobSpecDie)) *CronJobDie {
	return d.DieStamp(func(r *batchv1.CronJob) {
		d := CronJobSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

func (d *CronJobDie) Status(v batchv1.CronJobStatus) *CronJobDie {
	return d.DieStamp(func(r *batchv1.CronJob) {
		r.Status = v
	})
}

func (d *CronJobDie) StatusDie(fn func(d *CronJobStatusDie)) *CronJobDie {
	return d.DieStamp(func(r *batchv1.CronJob) {
		d := CronJobStatusBlank.DieImmutable(false).DieFeed(r.Status)
		fn(d)
		r.Status = d.DieRelease()
	})
}

var _ apismetav1.Object = (*CronJobDie)(nil)
var _ apismetav1.ObjectMetaAccessor = (*CronJobDie)(nil)
var _ runtime.Object = (*CronJobDie)(nil)

type CronJobSpecDie struct {
	mutable bool
	r       batchv1.CronJobSpec
}

var CronJobSpecBlank = (&CronJobSpecDie{}).DieFeed(batchv1.CronJobSpec{})

func (d *CronJobSpecDie) DieImmutable(immutable bool) *CronJobSpecDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

func (d *CronJobSpecDie) DieFeed(r batchv1.CronJobSpec) *CronJobSpecDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &CronJobSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *CronJobSpecDie) DieRelease() batchv1.CronJobSpec {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

func (d *CronJobSpecDie) DieStamp(fn func(r *batchv1.CronJobSpec)) *CronJobSpecDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

func (d *CronJobSpecDie) DeepCopy() *CronJobSpecDie {
	r := *d.r.DeepCopy()
	return &CronJobSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *CronJobSpecDie) Schedule(v string) *CronJobSpecDie {
	return d.DieStamp(func(r *batchv1.CronJobSpec) {
		r.Schedule = v
	})
}

func (d *CronJobSpecDie) StartingDeadlineSeconds(v *int64) *CronJobSpecDie {
	return d.DieStamp(func(r *batchv1.CronJobSpec) {
		r.StartingDeadlineSeconds = v
	})
}

func (d *CronJobSpecDie) ConcurrencyPolicy(v batchv1.ConcurrencyPolicy) *CronJobSpecDie {
	return d.DieStamp(func(r *batchv1.CronJobSpec) {
		r.ConcurrencyPolicy = v
	})
}

func (d *CronJobSpecDie) Suspend(v *bool) *CronJobSpecDie {
	return d.DieStamp(func(r *batchv1.CronJobSpec) {
		r.Suspend = v
	})
}

func (d *CronJobSpecDie) JobTemplate(v batchv1.JobTemplateSpec) *CronJobSpecDie {
	return d.DieStamp(func(r *batchv1.CronJobSpec) {
		r.JobTemplate = v
	})
}

func (d *CronJobSpecDie) SuccessfulJobsHistoryLimit(v *int32) *CronJobSpecDie {
	return d.DieStamp(func(r *batchv1.CronJobSpec) {
		r.SuccessfulJobsHistoryLimit = v
	})
}

func (d *CronJobSpecDie) FailedJobsHistoryLimit(v *int32) *CronJobSpecDie {
	return d.DieStamp(func(r *batchv1.CronJobSpec) {
		r.FailedJobsHistoryLimit = v
	})
}

type CronJobStatusDie struct {
	mutable bool
	r       batchv1.CronJobStatus
}

var CronJobStatusBlank = (&CronJobStatusDie{}).DieFeed(batchv1.CronJobStatus{})

func (d *CronJobStatusDie) DieImmutable(immutable bool) *CronJobStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

func (d *CronJobStatusDie) DieFeed(r batchv1.CronJobStatus) *CronJobStatusDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &CronJobStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *CronJobStatusDie) DieRelease() batchv1.CronJobStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

func (d *CronJobStatusDie) DieStamp(fn func(r *batchv1.CronJobStatus)) *CronJobStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

func (d *CronJobStatusDie) DeepCopy() *CronJobStatusDie {
	r := *d.r.DeepCopy()
	return &CronJobStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *CronJobStatusDie) Active(v ...corev1.ObjectReference) *CronJobStatusDie {
	return d.DieStamp(func(r *batchv1.CronJobStatus) {
		r.Active = v
	})
}

func (d *CronJobStatusDie) LastScheduleTime(v *apismetav1.Time) *CronJobStatusDie {
	return d.DieStamp(func(r *batchv1.CronJobStatus) {
		r.LastScheduleTime = v
	})
}

func (d *CronJobStatusDie) LastSuccessfulTime(v *apismetav1.Time) *CronJobStatusDie {
	return d.DieStamp(func(r *batchv1.CronJobStatus) {
		r.LastSuccessfulTime = v
	})
}

type JobDie struct {
	metav1.FrozenObjectMeta
	mutable bool
	r       batchv1.Job
}

var JobBlank = (&JobDie{}).DieFeed(batchv1.Job{})

func (d *JobDie) DieImmutable(immutable bool) *JobDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

func (d *JobDie) DieFeed(r batchv1.Job) *JobDie {
	if d.mutable {
		d.FrozenObjectMeta = metav1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &JobDie{
		FrozenObjectMeta: metav1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

func (d *JobDie) DieRelease() batchv1.Job {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

func (d *JobDie) DieStamp(fn func(r *batchv1.Job)) *JobDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

func (d *JobDie) DeepCopy() *JobDie {
	r := *d.r.DeepCopy()
	return &JobDie{
		FrozenObjectMeta: metav1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

func (d *JobDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *JobDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *JobDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *JobDie) UnmarshalJSON(b []byte) error {
	if d == JobBlank {
		return fmtx.Errorf("cannot unmarshal into the root object, create a copy first")
	}
	r := &batchv1.Job{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

func (d *JobDie) MetadataDie(fn func(d *metav1.ObjectMetaDie)) *JobDie {
	return d.DieStamp(func(r *batchv1.Job) {
		d := metav1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

func (d *JobDie) Spec(v batchv1.JobSpec) *JobDie {
	return d.DieStamp(func(r *batchv1.Job) {
		r.Spec = v
	})
}

func (d *JobDie) SpecDie(fn func(d *JobSpecDie)) *JobDie {
	return d.DieStamp(func(r *batchv1.Job) {
		d := JobSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

func (d *JobDie) Status(v batchv1.JobStatus) *JobDie {
	return d.DieStamp(func(r *batchv1.Job) {
		r.Status = v
	})
}

func (d *JobDie) StatusDie(fn func(d *JobStatusDie)) *JobDie {
	return d.DieStamp(func(r *batchv1.Job) {
		d := JobStatusBlank.DieImmutable(false).DieFeed(r.Status)
		fn(d)
		r.Status = d.DieRelease()
	})
}

var _ apismetav1.Object = (*JobDie)(nil)
var _ apismetav1.ObjectMetaAccessor = (*JobDie)(nil)
var _ runtime.Object = (*JobDie)(nil)

type JobSpecDie struct {
	mutable bool
	r       batchv1.JobSpec
}

var JobSpecBlank = (&JobSpecDie{}).DieFeed(batchv1.JobSpec{})

func (d *JobSpecDie) DieImmutable(immutable bool) *JobSpecDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

func (d *JobSpecDie) DieFeed(r batchv1.JobSpec) *JobSpecDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &JobSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *JobSpecDie) DieRelease() batchv1.JobSpec {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

func (d *JobSpecDie) DieStamp(fn func(r *batchv1.JobSpec)) *JobSpecDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

func (d *JobSpecDie) DeepCopy() *JobSpecDie {
	r := *d.r.DeepCopy()
	return &JobSpecDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *JobSpecDie) Parallelism(v *int32) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.Parallelism = v
	})
}

func (d *JobSpecDie) Completions(v *int32) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.Completions = v
	})
}

func (d *JobSpecDie) ActiveDeadlineSeconds(v *int64) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.ActiveDeadlineSeconds = v
	})
}

func (d *JobSpecDie) BackoffLimit(v *int32) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.BackoffLimit = v
	})
}

func (d *JobSpecDie) Selector(v *apismetav1.LabelSelector) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.Selector = v
	})
}

func (d *JobSpecDie) ManualSelector(v *bool) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.ManualSelector = v
	})
}

func (d *JobSpecDie) Template(v corev1.PodTemplateSpec) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.Template = v
	})
}

func (d *JobSpecDie) TTLSecondsAfterFinished(v *int32) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.TTLSecondsAfterFinished = v
	})
}

func (d *JobSpecDie) CompletionMode(v *batchv1.CompletionMode) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.CompletionMode = v
	})
}

func (d *JobSpecDie) Suspend(v *bool) *JobSpecDie {
	return d.DieStamp(func(r *batchv1.JobSpec) {
		r.Suspend = v
	})
}

type JobStatusDie struct {
	mutable bool
	r       batchv1.JobStatus
}

var JobStatusBlank = (&JobStatusDie{}).DieFeed(batchv1.JobStatus{})

func (d *JobStatusDie) DieImmutable(immutable bool) *JobStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

func (d *JobStatusDie) DieFeed(r batchv1.JobStatus) *JobStatusDie {
	if d.mutable {
		d.r = r
		return d
	}
	return &JobStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *JobStatusDie) DieRelease() batchv1.JobStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

func (d *JobStatusDie) DieStamp(fn func(r *batchv1.JobStatus)) *JobStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

func (d *JobStatusDie) DeepCopy() *JobStatusDie {
	r := *d.r.DeepCopy()
	return &JobStatusDie{
		mutable: d.mutable,
		r:       r,
	}
}

func (d *JobStatusDie) Conditions(v ...batchv1.JobCondition) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.Conditions = v
	})
}

func (d *JobStatusDie) StartTime(v *apismetav1.Time) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.StartTime = v
	})
}

func (d *JobStatusDie) CompletionTime(v *apismetav1.Time) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.CompletionTime = v
	})
}

func (d *JobStatusDie) Active(v int32) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.Active = v
	})
}

func (d *JobStatusDie) Succeeded(v int32) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.Succeeded = v
	})
}

func (d *JobStatusDie) Failed(v int32) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.Failed = v
	})
}

func (d *JobStatusDie) CompletedIndexes(v string) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.CompletedIndexes = v
	})
}

func (d *JobStatusDie) UncountedTerminatedPods(v *batchv1.UncountedTerminatedPods) *JobStatusDie {
	return d.DieStamp(func(r *batchv1.JobStatus) {
		r.UncountedTerminatedPods = v
	})
}
